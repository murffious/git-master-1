 selecting algorithms depends on knowledge of the data they will be operating on. Namely, because:
Efficiency speed:  if we're clever, we can write code that minimizes the amount of work the computer needs to do to sort the array.
 meaning like the number of "steps" the computer needs to run;
 tradeoff between performant and readable code.
  efficiencies of sorting algorithms depends on things like:
How big the data set is—insertion sort is a good default for small arrays.
How ordered the data is—i.e., whether it's completely out of order, or partially sorted.
How many unique elements there are.
Different algorithms have different strengths and weaknesses—e.g., insertion sort handles nearly sorted arrays quickly, but quick-sort is substantially faster on mostly unordered inputs.
Selecting an algorithm means choosing the best tool for your particular use case.


insertion sort algorithm 
insertion sort is more efficient than quick-sort. Namely:
while simple, insertion sort is intolerably slow for average arrays, with a running time of O(n2).
For small arrays; and
For mostly-sorted arrays.


 quick-sort algorithm 


 "Selection Sort"
  one of the more inefficient sorting algorithms.


Key wor/ strategies
 pivot
  partitioning
  sub-arrays
  temp
   iteration,
   index


